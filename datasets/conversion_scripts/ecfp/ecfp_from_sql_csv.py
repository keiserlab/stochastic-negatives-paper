import argparse
from multiprocessing import cpu_count, Pool
from rdkit.Chem import MolFromSmiles
from rdkit.Chem.Draw import SimilarityMaps as CSM
from rdkit import Chem
import standardiser
from standardiser import standardise
from standardiser.utils import StandardiseException, errors
import gzip
import csv

__author__ = "Elena Caceres"
__credits__ = []
__email__ = "ecaceres@keiserlab.org"


def fingerprint_mp_wrapper(args):
    smiles, target, activity, relation, kwargs = args
    fp = get_sim_fingerprint(smiles, **kwargs)
    if fp is not None:
        return(fp.ToBitString(), target, activity, relation)
    else:
        return(fp, target, activity, relation)


def get_sim_fingerprint(smiles, **kwargs):
    """Calculates the Morgan fingerprint

    Parameters
    ----------
    smiles : str
        SMILES string to fingerprint
    **kwargs
        radius : int (default 2)
            the maximum radius
        nBits : int (default 1024)
            size of the bit vector (only for fpType = 'bv')

        fpType : str (default 'bv')
            the type of Morgan fingerprint -- 'count' or 'bv' (bitvector)

        useFeatures : bool (default False)
            if false - ConnectivityMorgan, if true: FeatureMorgan

    Returns
    -------
    rdkit.DataStructs.cDataStructs.ExplicitBitVect : 2D ndarray the Morgan
    fingerprint with the environments of atomId removed
    """

    kwargs.setdefault('radius', 2)
    kwargs.setdefault('nBits', 1024)
    kwargs.setdefault('fpType', 'bv')
    kwargs.setdefault('useFeatures', False)
    mol = MolFromSmiles(smiles)
    # standardize mol
    if mol is None:
        print("\tCould not create mol object from %s,"
              " because mol == Nonetype" % smiles)
        return None
    # Filter for mols that can't be standardised
    try:
        std_mol = standardise.apply(mol)
    except StandardiseException, e:
        print("\tUsed unstandardised mol. Could not create"
              "standardised ECFP from %s, because of "
              "standardise exception error: %s" % (smiles, e))
        # make note, but return unstandardized mol. We'll just count this as
        # random noise
        return CSM.GetMorganFingerprint(mol, **kwargs)
    return CSM.GetMorganFingerprint(std_mol, **kwargs)


def run(in_file, out_file, **kwargs):
    """Gets and builds the dataset for initial experiments for multi-label MLP
    tests (2015-08-17). Saves file to tmp with smiles and vector of binding
    affinities for conversion to ECFP. Will contain header line with format:

    SMILES  ChEMBL_Molecule_ID  Target  Activity    Relation

    Where Activity (for now) is set to the exact value specified in
    ~/chembl20_minibatching/chembl20_pylearn2_data/chembl20_activity_list_all.txt.gz

    Parameters
    ----------
    username : str
            username to log into database
    out_file : str
            path to save final .csv file to
    **kwargs
        radius : int (default 2)
            the maximum radius
        nBits : int (default 1024)
            size of the bit vector (only for fpType = 'bv')

        fpType : str (default 'bv')
            the type of Morgan fingerprint -- 'count' or 'bv' (bitvector)

        useFeatures : bool (default False)
            if false - ConnectivityMorgan, if true: FeatureMorgan

    Returns
    -------
    """
    num_cpus = cpu_count()
    ppool = Pool(num_cpus)
    kwargs.setdefault('radius', 2)
    kwargs.setdefault('nBits', 1024)
    kwargs.setdefault('fpType', 'bv')
    kwargs.setdefault('useFeatures', False)

    # ==========================================================================
    # read file & create values
    # ==========================================================================
    # read our smiles file
    with open(in_file, 'rb') as f:
        reader = csv.reader(f, delimiter='\t')
        # skip header file...
        reader.next()
        args = ((smi, tgt, act, rel, kwargs)
                for smi, id,  tgt, act, rel in reader)
        fps = ppool.map(fingerprint_mp_wrapper, args, chunksize=100)

    # remove None types from our data.
    clean_fps = [i for i in fps if i is not None]
    dirty_fps = [j for j in fps if j is None]

    # write our new bitvectors to file.
    with open(out_file, 'wb') as f:
        writer = csv.writer(f, delimiter='\t')
        for fp, tgt, act, rel in clean_fps:
            writer.writerow([fp, tgt, act, rel])

    return dirty_fps

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        "Generate ECFP file for use with pylearn2 wrapper in the format: \n"
        "ECFP   Target  Activity    Relation\n"
        "Original dataset generated by: "
        "mysql_small_dataset_for_weak_labels.py")
    parser.add_argument('in_file', type=str,
                        help="""Input file to convert SMILES to ECFP. Must
                                contain header""")
    parser.add_argument('out_file', type=str,
                        help="""path to save final data""")
    parser.add_argument('-b', '--nBits', type=int, default=1024,
                        help="""Length of fingerprint bitvector after folding
                                (default 1024)""")
    parser.add_argument('-r', '--radius', type=int, default=2,
                        help="""ECFP radius (default 2)""")
    parser.add_argument('-t', '--fpType', type=str, default='bv',
                        help=""" the type of Morgan fingerprint -- 'count' or
                        'bv' (bitvector, default)""")
    parser.add_argument('-f', '--useFeatures', type=bool, default=False,
                        help="""If false (default) - ConnectivityMorgan, if true:
                                 FeatureMorgan""")

    params = parser.parse_args()
    kwargs = dict(params._get_kwargs())
    username = kwargs.pop('in_file')
    out_file = kwargs.pop('out_file')

    print run(username, out_file, **kwargs)
